# -*- coding: utf-8 -*-
"""fitness_api.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uj85_DeAGCzI-pPuZDNiCGx4MD3G-NGT
"""

'''
GET /classes: Returns a list of all upcoming fitness classes (name, date/time, instructor, available slots)

POST /book: Accepts a booking request (class_id, client_name, client_email)
Validates if slots are available, and reduces available slots upon successful booking

GET /bookings: Returns all bookings made by a specific email address
'''

'''
Technical Expectations:

Use Python with any backend framework of your choice (FastAPI preferred)
Use an in-memory DB like SQLite or store data in a file (no need to set up a full DB)
Write clean, modular, and well-documented code

Timezone management:

 Classes created in IST and on change of timezone all the slots should be changed accordingly
Handle errors and edge cases (e.g., overbooking, missing fields)
Add basic input validation, logging, or unit tests'''

# main.py

from fastapi import FastAPI, HTTPException, Request, status
from pydantic import BaseModel, EmailStr
from typing import List, Dict
import datetime
import pytz
import uuid
import logging

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# In-memory data store
classes_db: Dict[str, Dict] = {}
bookings_db: Dict[str, Dict] = {}

# Timezone for class creation
IST = pytz.timezone('Asia/Kolkata')

class_id_counter = 0

def create_class(name: str, date_time_str: str, instructor: str, total_slots: int):
    """Helper function to create a class and add it to the database."""
    global class_id_counter
    class_id_counter += 1
    class_id = str(class_id_counter)

    try:
        naive_datetime = datetime.datetime.strptime(date_time_str, "%Y-%m-%d %H:%M")
        datetime_ist = IST.localize(naive_datetime)
    except ValueError:
        logger.error(f"Invalid datetime format: {date_time_str}")
        return None

    class_info = {
        "id": class_id,
        "name": name,
        "datetime_ist": datetime_ist,
        "instructor": instructor,
        "total_slots": total_slots,
        "available_slots": total_slots,
    }
    classes_db[class_id] = class_info
    logger.info(f"Created class: {name} with ID: {class_id}")
    return class_info

# Populate with some initial data (example)
# ... (your create_class calls)
create_class("Yoga Beginners", "2023-10-28 10:00", "Anya Sharma", 15)
create_class("Zumba Fitness", "2023-10-29 18:30", "Rahul Singh", 20)
create_class("Pilates Core", "2023-11-01 09:00", "Priya Kapoor", 10)
future_date_time = datetime.datetime.now(IST) + datetime.timedelta(days=7)
create_class("Future Cycling", future_date_time.strftime("%Y-%m-%d %H:%M"), "Bob", 12)


class ClassResponse(BaseModel):
    id: str
    name: str
    datetime: str
    instructor: str
    available_slots: int

class BookingRequest(BaseModel):
    class_id: str
    client_name: str
    client_email: EmailStr

class BookingResponse(BaseModel):
    id: str
    class_id: str
    client_name: str
    client_email: EmailStr
    booking_time: str

@app.get("/classes", response_model=List[ClassResponse])
async def get_classes(timezone: str = 'UTC'):
    # ... (your get_classes implementation)
    try:
        target_timezone = pytz.timezone(timezone)
    except pytz.UnknownTimeZoneError:
        raise HTTPException(status_code=400, detail=f"Invalid timezone: {timezone}")

    upcoming_classes = []
    now = datetime.datetime.now(IST) # Compare with current time in IST

    for class_id, class_info in classes_db.items():
        # Only include classes that are in the future (based on IST)
        if class_info["datetime_ist"] > now:
            # Convert class time to the target timezone for the response
            datetime_target_tz = class_info["datetime_ist"].astimezone(target_timezone)
            upcoming_classes.append(ClassResponse(
                id=class_id,
                name=class_info["name"],
                datetime=datetime_target_tz.strftime("%Y-%m-%d %H:%M %Z%z"), # Format with timezone info
                instructor=class_info["instructor"],
                available_slots=class_info["available_slots"],
            ))

    logger.info(f"Returning {len(upcoming_classes)} upcoming classes for timezone: {timezone}")
    return upcoming_classes


@app.post("/book", response_model=BookingResponse, status_code=status.HTTP_201_CREATED)
async def book_class(booking_request: BookingRequest):
    # ... (your book_class implementation)
    class_id = booking_request.class_id
    client_email = booking_request.client_email.lower() # Store email lowercase for consistency

    if class_id not in classes_db:
        logger.warning(f"Booking failed: Class ID {class_id} not found")
        raise HTTPException(status_code=404, detail="Class not found")

    class_info = classes_db[class_id]

    # Check if the class is in the future (based on IST)
    now = datetime.datetime.now(IST)
    if class_info["datetime_ist"] <= now:
        logger.warning(f"Booking failed: Class ID {class_id} is in the past.")
        raise HTTPException(status_code=400, detail="Cannot book past classes")

    # Check for availability
    if class_info["available_slots"] <= 0:
        logger.warning(f"Booking failed: No available slots for class ID {class_id}")
        raise HTTPException(status_code=400, detail="No available slots")

    # Check if the client has already booked this class (basic check)
    for booking in bookings_db.values():
        if booking["class_id"] == class_id and booking["client_email"] == client_email:
            logger.warning(f"Booking failed: Client {client_email} already booked class {class_id}")
            raise HTTPException(status_code=400, detail="You have already booked this class")

    # Process the booking
    booking_id = str(uuid.uuid4())
    booking_time_utc = datetime.datetime.now(pytz.utc) # Record booking time in UTC

    booking_info = {
        "id": booking_id,
        "class_id": class_id,
        "client_name": booking_request.client_name,
        "client_email": client_email,
        "booking_time_utc": booking_time_utc,
    }
    bookings_db[booking_id] = booking_info

    # Reduce available slots
    classes_db[class_id]["available_slots"] -= 1

    logger.info(f"Booking successful for client {client_email} in class {class_id}. Booking ID: {booking_id}")

    return BookingResponse(
        id=booking_id,
        class_id=class_id,
        client_name=booking_request.client_name,
        client_email=client_email,
        booking_time=booking_time_utc.strftime("%Y-%m-%d %H:%M %Z%z") # Return booking time in UTC
    )

@app.get("/bookings", response_model=List[BookingResponse])
async def get_bookings_by_email(client_email: EmailStr):
    # ... (your get_bookings_by_email implementation)
    client_email_lower = client_email.lower()
    client_bookings = []
    for booking_id, booking_info in bookings_db.items():
        if booking_info["client_email"] == client_email_lower:
            client_bookings.append(BookingResponse(
                id=booking_id,
                class_id=booking_info["class_id"],
                client_name=booking_info["client_name"],
                client_email=booking_info["client_email"],
                booking_time=booking_info["booking_time_utc"].strftime("%Y-%m-%d %H:%M %Z%z") # Return booking time in UTC
            ))
    logger.info(f"Returning {len(client_bookings)} bookings for email: {client_email}")
    return client_bookings